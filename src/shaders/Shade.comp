#version 430

#extension GL_ARB_bindless_texture : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uniform layout(rgba16f) image2D ColorOutput;

#include "common/BVH.glsl"

layout(std430) readonly buffer samplers {
    vec4 materialInstance[];
};

layout(std430) buffer rayBufferW {
    vec4 raysW[];
};

layout(std430) buffer rayBufferR {
    vec4 raysR[];
};

layout(binding = 0, offset = 0) uniform atomic_uint rayWriteCounter;
layout(binding = 0, offset = 4) uniform atomic_uint rayReadCounter;
layout(binding = 0, offset = 12) uniform atomic_uint raysWritten;

uniform vec3 lightPos;

#define M_PI 3.141529

void main(){
    uint idxR = atomicCounterIncrement(rayReadCounter);
    if(idxR >= atomicCounter(raysWritten)) return;
    idxR *= 5;

	uvec2 PixelCoordinates;
    Vertex currVertex;
    vec3 throughPut, accum;

    PixelCoordinates.x = floatBitsToUint( raysR[idxR].x);
    PixelCoordinates.y = floatBitsToUint( raysR[idxR].y);
    throughPut.xy      = raysR[idxR  ].zw;
    throughPut.z       = raysR[idxR+1].x;
    accum              = raysR[idxR+1].yzw;
    currVertex.Position          =                raysR[idxR+2].xyz;
    currVertex.Normal.x          =                raysR[idxR+2].w  ;
    currVertex.Normal.yz         =                raysR[idxR+3].xy ;
    currVertex.TextureCoordinate =                raysR[idxR+3].zw ;
    currVertex.MatID             = floatBitsToInt(raysR[idxR+4].x) ;

    if(floatBitsToInt(materialInstance[currVertex.MatID + 1].w) == 1) {
        imageStore(ColorOutput, ivec2(PixelCoordinates), vec4(throughPut * materialInstance[currVertex.MatID + 1].xyz, 1.0));
    }

        //imageStore(ColorOutput, ivec2(gl_GlobalInvocationID.xy), vec4(currVertex.Position, 1.0));

    vec3 albedo = texture(sampler2D(floatBitsToUint(materialInstance[currVertex.MatID].xy)), currVertex.TextureCoordinate).xyz;
    float lightDist = distance(lightPos, currVertex.Position);


    Ray shadowRay;
    shadowRay.Origin = currVertex.Position + 0.001 * currVertex.Normal;
    shadowRay.Direction = (lightPos - currVertex.Position) / lightDist;
    
    float attenuation = 1.0 / (4.0 * M_PI * lightDist * lightDist);
    float ndotl = max(0.0, dot(currVertex.Normal, shadowRay.Direction));
    vec3 brdf = albedo / M_PI * ndotl * attenuation;

    uint idxW        = atomicCounterIncrement(rayWriteCounter);
    idxW *= 5;
    //idxW = idxR;

    // PixelCoordinates = uvec2(idxR, idxW);

    raysW[idxW  ].xy  = uintBitsToFloat(PixelCoordinates);
    raysW[idxW  ].zw  = throughPut.xy * brdf.xy;
    raysW[idxW+1].x   = throughPut.z * brdf.z;
    raysW[idxW+2].yzw = accum;
    raysW[idxW+2].xyz = shadowRay.Origin;
    raysW[idxW+3].xyz = shadowRay.Direction;



}