#version 430

#extension GL_ARB_bindless_texture : enable

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

uniform layout(rgba32f) image2D colorOutput;

#include "common/BVH.glsl"
#include "common/Random.glsl"

layout(std430) readonly buffer samplers {
    vec4 materialInstance[];
};

layout(std430) buffer rayBufferW {
    vec4 raysW[];
};

layout(std430) buffer rayBufferR {
    vec4 raysR[];
};

layout(binding = 0, offset = 0) uniform atomic_uint rayWriteCounter;
layout(binding = 0, offset = 4) uniform atomic_uint rayReadCounter;
layout(binding = 0, offset = 12) uniform atomic_uint raysWritten;

uniform int width, height;

#define M_PI 3.141529

vec3 CosineWeightedDirection() {
    float r0 = rand(), r1 = rand();
    float r = sqrt(r0);
    float phi = 2 * M_PI * r1;
    return vec3(r * vec2(sin(phi), cos(phi)), sqrt(1.0 - r0));
}

void main(){
    

    uint idxR = atomicCounterIncrement(rayReadCounter);
    if(idxR >= atomicCounter(raysWritten)) return;
    idxR *= 5;

	ivec2 PixelCoordinates;
    Vertex currVertex;
    vec3 throughPut, accum, viewDir;

    PixelCoordinates.xy= floatBitsToInt( raysR[idxR].xy);
    throughPut.xy      = raysR[idxR  ].zw;
    throughPut.z       = raysR[idxR+1].x;
    accum              = raysR[idxR+1].yzw;
    currVertex.Position          =                raysR[idxR+2].xyz;
    currVertex.Normal.x          =                raysR[idxR+2].w  ;
    currVertex.Normal.yz         =                raysR[idxR+3].xy ;
    currVertex.TextureCoordinate =                raysR[idxR+3].zw ;
    currVertex.MatID             = floatBitsToInt(raysR[idxR+4].x) ;
    viewDir                      =                raysR[idxR+4].yzw;

    if(floatBitsToInt(materialInstance[currVertex.MatID + 1].w) == 1) {
        vec3 currRadiance = throughPut * (currVertex.MatID == 0 ? texture(samplerCube(floatBitsToUint(materialInstance[0].xy)), viewDir).xyz :   materialInstance[currVertex.MatID + 1].xyz);
        vec3 accumRadiance = imageLoad(colorOutput, PixelCoordinates).xyz + currRadiance;
        imageStore(colorOutput, PixelCoordinates,vec4(accumRadiance, 1.0));
        return;
    }

    initRNG(PixelCoordinates.y * width + PixelCoordinates.x);

    vec3 normcrs = (abs(currVertex.Normal.y) > 0.99 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));
    vec3 tangent = normalize(cross(normcrs, currVertex.Normal));
    vec3 bitangent = cross(tangent, currVertex.Normal);

    Ray sampleRay;
    sampleRay.Origin = currVertex.Position + 0.001 * currVertex.Normal;
    sampleRay.Direction = mat3(tangent, bitangent, currVertex.Normal) * CosineWeightedDirection();


    vec3 albedo = texture(sampler2D(floatBitsToUint(materialInstance[currVertex.MatID].xy)), currVertex.TextureCoordinate).xyz;
    float pdf = 1.0 / (2 * M_PI);
    float ndotl = max(0.0, dot(currVertex.Normal, sampleRay.Direction));
    vec3 brdf = albedo / M_PI;
    vec3 reflectedIrradiance = brdf;// * ndotl / pdf;
    throughPut *= reflectedIrradiance;

    float continuation = max(throughPut.x, max(throughPut.y, throughPut.z));
    if(rand() >= continuation) {
        freeRNG();
        return;
    }
    throughPut /= continuation;


    uint idxW        = atomicCounterIncrement(rayWriteCounter);
    idxW *= 5;
    //idxW = idxR;

    // PixelCoordinates = uvec2(idxR, idxW);

    raysW[idxW  ].xy  = uintBitsToFloat(PixelCoordinates);
    raysW[idxW  ].zw  = throughPut.xy;
    raysW[idxW+1].x   = throughPut.z;
    raysW[idxW+2].yzw = accum;
    raysW[idxW+2].xyz = sampleRay.Origin;
    raysW[idxW+3].xyz = sampleRay.Direction;

    freeRNG();
}