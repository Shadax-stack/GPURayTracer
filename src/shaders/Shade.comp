#version 430

#extension GL_ARB_bindless_texture : enable

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

uniform layout(rgba32f) image2D directAccum;

#include "common/BVH.glsl"
#include "common/Random.glsl"
#include "common/Constants.glsl"

layout(std430) readonly buffer samplers {
    vec4 materialInstance[];
};

layout(std430) buffer rayBufferW {
    vec4 raysW[];
};

layout(std430) buffer rayBufferR {
    vec4 raysR[];
};

layout(binding = 0, offset = 0) uniform atomic_uint rayWriteCounter;
layout(binding = 0, offset = 4) uniform atomic_uint rayReadCounter;
layout(binding = 0, offset = 12) uniform atomic_uint raysWritten;

uniform int width, height;

vec3 CosineWeightedDirection() {
    float r0 = rand(), r1 = rand();
    float r = sqrt(r0); 
    float phi = 2 * M_PI * r1;
    return vec3(r * vec2(sin(phi), cos(phi)), sqrt(1.0 - r0));
}

uniform samplerBuffer lightTex;
uniform float totalLightArea;

/*
    int a = 0, b = textureSize(lightTex) / 9 - 1;

    while(a > b) {
        int m = a+b / 2;
        float currArea = texelFetch(lightTex, 9 * m + 2).y;
        if(currArea > selectedArea)
            b = m - 1;
        else
            a = m + 1;
    }

    int idx = 9 * a;
*/

void RandomPointOnLight(out vec3 position, out vec3 normal) {
    float selectedArea = rand() * totalLightArea;
    int a = 0, b = textureSize(lightTex) / 9 - 1;

    while(b > a) {
        int m = (a + b) / 2;
        float currArea = texelFetch(lightTex, 9 * m + 2).y;
        if(currArea > selectedArea)
            b = m - 1;
        else
            a = m + 1;
    }

    int idx = 9 * a;

    Triangle selectedTriangle;

    selectedTriangle.Vertices[0].PN = texelFetch(lightTex, idx);
    selectedTriangle.Vertices[0].NT = texelFetch(lightTex, idx + 1);
    selectedTriangle.Vertices[1].PN = texelFetch(lightTex, idx + 3);
    selectedTriangle.Vertices[1].NT = texelFetch(lightTex, idx + 4);
    selectedTriangle.Vertices[2].PN = texelFetch(lightTex, idx + 6);
    selectedTriangle.Vertices[2].NT = texelFetch(lightTex, idx + 7);

    float u = rand(), v = rand(), t = rand();
    float s = u + v + t;

    u /= s;
    v /= s;
    t /= s;

    position = selectedTriangle.Vertices[0].PN.xyz * u + selectedTriangle.Vertices[1].PN.xyz * v + selectedTriangle.Vertices[2].PN.xyz * t;
    normal   = vec3(selectedTriangle.Vertices[0].PN.w, selectedTriangle.Vertices[0].NT.xy) * v + vec3(selectedTriangle.Vertices[1].PN.w, selectedTriangle.Vertices[1].NT.xy) * u + vec3(selectedTriangle.Vertices[2].PN.w, selectedTriangle.Vertices[2].NT.xy) * t;
}

uniform int bounce;

void main(){
    

    uint idxR = atomicCounterIncrement(rayReadCounter);
    if(idxR >= atomicCounter(raysWritten)) return;
    idxR *= 5;

	ivec2 PixelCoordinates;
    Vertex currVertex;
    vec3 throughput, viewDir;
    int sampleType;

    PixelCoordinates.xy= floatBitsToInt( raysR[idxR].xy);
    throughput         = raysR[idxR+1].xyz;
    sampleType         = fbs(raysR[idxR+1].w);
    currVertex.Position          =                raysR[idxR+2].xyz;
    currVertex.Normal.x          =                raysR[idxR+2].w  ;
    currVertex.Normal.yz         =                raysR[idxR+3].xy ;
    currVertex.TextureCoordinate =                raysR[idxR+3].zw ;
    currVertex.MatID             = floatBitsToInt(raysR[idxR+4].x) ;
    viewDir                      =                raysR[idxR+4].yzw;

    if(floatBitsToInt(materialInstance[currVertex.MatID + 1].w) == 1 && ((sampleType == 1 || bounce == 0) || (sampleType == 0 && currVertex.MatID == 0 ))) {
        vec3 currRadiance = throughput * (currVertex.MatID == 0 ? texture(samplerCube(floatBitsToUint(materialInstance[0].xy)), viewDir).xyz :   materialInstance[currVertex.MatID + 1].xyz);
        vec3 accumRadiance = imageLoad(directAccum, PixelCoordinates).xyz + currRadiance;
        imageStore(directAccum, PixelCoordinates,vec4(accumRadiance, 1.0));
        return;
    }

    initRNG(PixelCoordinates.y * width + PixelCoordinates.x);

    vec3 albedo = texture(sampler2D(floatBitsToUint(materialInstance[currVertex.MatID].xy)), currVertex.TextureCoordinate).xyz;
    vec3 brdf = albedo / M_PI;

    // Indirect ray
    {
        vec3 normcrs = (abs(currVertex.Normal.y) > 0.99 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));
        vec3 tangent = normalize(cross(normcrs, currVertex.Normal));
        vec3 bitangent = cross(tangent, currVertex.Normal);

        Ray ray;
        ray.Origin = currVertex.Position + 0.001 * currVertex.Normal;
        ray.Direction = mat3(tangent, bitangent, currVertex.Normal) * CosineWeightedDirection();

        vec3 indirectThroughput = throughput * brdf;
        float continuation = max(indirectThroughput.x, max(indirectThroughput.y, indirectThroughput.z));
        if(rand() < continuation) {
            indirectThroughput /= continuation;
            uint idxW        = atomicCounterIncrement(rayWriteCounter);
            idxW *= 5;
            raysW[idxW  ].xy  = uintBitsToFloat(PixelCoordinates);
            raysW[idxW+1].xyz = indirectThroughput;
            raysW[idxW+1].w   = intBitsToFloat(0);
            raysW[idxW+2].xyz = ray.Origin;
            raysW[idxW+3].xyz = ray.Direction;
        }
    }

    // NEE ray
    {
        vec3 lightPosition, lightNormal;
        RandomPointOnLight(lightPosition, lightNormal);
        float radius = distance(currVertex.Position, lightPosition);

        vec3 lightDir = (lightPosition - currVertex.Position) / radius;

        Ray ray;
        ray.Origin = currVertex.Position + 0.001 * currVertex.Normal;
        ray.Direction = lightDir;

        float geometric = max(dot(currVertex.Normal, lightDir), 0.0) * max(dot(lightNormal, -lightDir), 0.0)  / (radius * radius);
        vec3 directThroughput = throughput * brdf * geometric * totalLightArea;
        float continuation = max(directThroughput.x, max(directThroughput.y, directThroughput.z));
        if(rand() < continuation) {
            directThroughput /= continuation;
            uint idxW        = atomicCounterIncrement(rayWriteCounter);
            idxW *= 5;
            raysW[idxW  ].xy  = uintBitsToFloat(PixelCoordinates);
            raysW[idxW+1].xyz = directThroughput;
            raysW[idxW+1].w   = intBitsToFloat(1);
            raysW[idxW+2].xyz = ray.Origin;
            raysW[idxW+3].xyz = ray.Direction;
        }
    }


    freeRNG();
}

/*
vec3 randomPoint = RandomPointOnLight();
float radius = distance(currVertex.Position, randomPoint);

vec3 lightDir = (randomPoint - currVertex.Position) / radius;

Ray ray;
ray.Origin = currVertex.Position + 0.001 * currVertex.Normal;
ray.Direction = lightDir;

float geometric = max(dot(currVertex.Normal, lightDir), 0.0) * max(dot(vec3(0.0, -1.0, 0.0), -lightDir), 0.0)  / (radius * radius);
vec3 directThroughput = throughput * brdf * geometric * lightArea;
*/