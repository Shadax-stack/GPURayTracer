#version 430

vec3 debugColor;

#extension GL_ARB_bindless_texture : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uniform layout(rgba16f) image2D ColorOutput;

//uniform sampler2D RayOrigin;
//uniform sampler2D RayDirection;

#include "../../shading/BRDF.glsl"
#include "../../shading/Material.glsl"
#include "../../camera/Pinhole.glsl"
#include "../../geometry/Triangle.glsl"
#include "../../geometry/AABB.glsl"
#include "../../accelstruct/Traverse.glsl"

// Sky by builderboy
// Original coeffs: vec3(0.0625, 0.125, 0.25)
vec3 ComputeIncomingRadiance(in vec3 Direction) {
	float UpDot = Direction.y;
	const vec3 Coefficients =vec3(0.0625, 0.125, 0.25); //  0.1686, 0.4, 0.8667
	vec3 Color = Coefficients / (UpDot * UpDot + Coefficients);
	return Color;
}

layout(std430) buffer Samplers {
    readonly uvec2 Handles[];
};

vec3 SunDir = normalize (vec3(-5.0f, 15.0f, 0.0f));
vec3 SunCol = vec3(1.3f, 0.9f, 0.45f);
vec3 Ambient = vec3(0.2);

int NumSamples = 4;
int NumBounces = 2;


uniform int FrameNum;

//RNG from code by Moroz Mykhailo (https://www.shadertoy.com/view/wltcRS)

//internal RNG state 
uvec4 seed;
ivec2 pixel;

void InitRNG(vec2 p, int frame)
{
    pixel = ivec2(p);
    seed = uvec4(p, uint(frame), uint(p.x) + uint(p.y));
}

void pcg4d(inout uvec4 v)
{
    v = v * 1664525u + 1013904223u;
    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;
    v = v ^ (v >> 16u);
    v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;
}

float rand()
{
    pcg4d(seed); return float(seed.x) / float(0xffffffffu);
}

layout(std430) readonly buffer RayBuffer {
    vec4 rays[];
};

layout(binding = 0, offset = 4) uniform atomic_uint rayCounter;


vec3 ComputeColor(out uvec2 PixelCoordinates, out bool HitResult){
    vec3 Color = vec3(0.0f);

    Ray ray;
    
    uint idx = atomicCounterIncrement(rayCounter) * 2;
    
    ray.Origin.xyz = rays[idx  ].xyz;
    ray.Direction.x = rays[idx  ].w;
    ray.Direction.yz = rays[idx+1].xy;
    PixelCoordinates.x = floatBitsToUint( rays[idx+1].z);
    PixelCoordinates.y = floatBitsToUint( rays[idx+1].w);

    // Initialize our intersection data based off the last intersection test with the previous mesh within our scene
    HitInfo IntersectionInfo;
    IntersectionInfo.Depth = 1e20;

    //vec3 debugColor = vec3(0.0);

    if(HitResult = TraverseBVH2(ray, IntersectionInfo)) {
        Vertex InterpolatedVertex = GetInterpolatedVertex(IntersectionInfo);
        Color = texture(sampler2D(Handles[InterpolatedVertex.MatID]), InterpolatedVertex.TextureCoordinate).rgb;
    }

    //Color = debugColor;

    // TODO: More accurate sRGB conversion
    Color = pow(Color, vec3(1.0f / 2.2f));

	return Color;
}

void main(){
    InitRNG(vec2(gl_GlobalInvocationID.xy), FrameNum);

	uvec2 PixelCoordinates;
    bool HitResult;
    vec3 Color = ComputeColor(PixelCoordinates, HitResult);

    imageStore(ColorOutput, ivec2(PixelCoordinates), vec4(Color, 1.0f));
}

/*
vec4 ComputeColor(in ivec2 PixelCoordinates){
    vec3 Color = vec3(0.0f);

    Ray PrimaryRay;
    // I could use texelFetch here but whatever
    PrimaryRay.Origin    = imageLoad(RayOrigin   , PixelCoordinates).rgb;
    PrimaryRay.Direction = imageLoad(RayDirection, PixelCoordinates).rgb;

    HitInfo IntersectionInfo;

    IntersectionInfo.Depth = imageLoad(IntersectionDepth, PixelCoordinates).r;

    bool HitResult = TraverseBVH(Mesh, BVH, PrimaryRay, IntersectionInfo);

    if(HitResult) {
        Vertex InterpolatedVertex = GetInterpolatedVertex(IntersectionInfo);

        Color = vec3(1.0f);//texture(Material.Diffuse, InterpolatedVertex.TextureCoordinate).rgb;

        // Reflection and refraction

        vec3 RefractedRay = refract(PrimaryRay.Direction, InterpolatedVertex.Normal, 1.0 / 1.333f);
        vec3 ReflectedRay = reflect(PrimaryRay.Direction, InterpolatedVertex.Normal);

        Color *= (ComputeIncomingRadiance(RefractedRay) + ComputeIncomingRadiance(ReflectedRay)) / 2.0f;
    } else {
        Color = ComputeIncomingRadiance(PrimaryRay.Direction);
    }

    // TODO: More accurate sRGB conversion
    Color = pow(Color, vec3(1.0f / 2.2f));

	return vec4(Color, IntersectionInfo.Depth);
}

void main(){
	uvec2 PixelCoordinates = gl_GlobalInvocationID.xy;
    ivec2 StoreLocation = ivec2(PixelCoordinates);

    vec4 Color = ComputeColor(StoreLocation);
    
    if(StoreLocation.x > 640)
    imageStore(ColorOutput, StoreLocation, vec4(Color.w / 500.0f));
    imageStore(IntersectionDepth, StoreLocation, vec4(Color.w));
}

        uint seed0 = gl_GlobalInvocationID.x * 3;
        uint seed1 = gl_GlobalInvocationID.y* 2;

        
        vec3 Accum = vec3(0.0f);

        for(int i = 0; i < NumSamples; i++) {
            vec3 ThroughPut = vec3(1.0);
            Ray RandomRay;

            Vertex CurrentVertex = InterpolatedVertex;
            for(int j = 0; j < NumBounces; j++) {
                RandomRay.Origin = CurrentVertex.Position;

                float r0 = getrandom(seed0, seed1);
                float r1 = getrandom(seed0, seed1);

                float r = sqrt(r0);
                float theta = 2 * 3.1412529 * r1;
                float x = r * cos(theta);
                float y = r * sin(theta);
                
                RandomRay.Direction = vec3(x, y, sqrt(1 - r0));
                vec3 tangent = normalize(cross(vec3(0.15, 0.15, 0.34f), CurrentVertex.Normal));
                vec3 bitangent = cross(tangent, CurrentVertex.Normal);

                RandomRay.Direction = mat3(tangent, bitangent, CurrentVertex.Normal) * RandomRay.Direction;

                HitInfo NextIsect;
                NextIsect.Depth = 1e20;
                bool HitWorld = TraverseBVH(Mesh, BVH, RandomRay, NextIsect);

                if(HitWorld) {
                    CurrentVertex = GetInterpolatedVertex(NextIsect);
                    ThroughPut *= texture(sampler2D(Handles[CurrentVertex.MatID]), CurrentVertex.TextureCoordinate).rgb;
                } else {
                    Accum += ThroughPut * ComputeIncomingRadiance(RandomRay.Direction);
                    break;
                }

            }
        }
*/