#version 430

vec3 debugColor;

#extension GL_ARB_bindless_texture : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "common/Geometry.glsl"
#include "common/BVH.glsl"
#include "common/Random.glsl"
#include "common/Constants.glsl"
#include "common/Util.glsl"
#include "common/Material.glsl"

uniform vec3 lower_left, horizontal, vertical, position, u, v;
uniform int width, height;
uniform float lens_radius;

uniform samplerBuffer lightTex;
uniform float totalLightArea;

uniform float kMetallic;

uniform layout(rgba32f) image2D accum;

// See madmann's implementation https://github.com/madmann91/sol/blob/master/include/sol/renderer.h#L57
float MISWeight(in float top, in float bottom) {
    // Assume for each path we send one nee and one indirect sample, factor out 0.5
    // return (top) / (top + bottom); // Your screen gets overtaken by NaNs when you are doing specular reflections
    return 1.0f / (1.0f + bottom / top);
}

// I will eventually need to move away from global vars
float metalness;
float roughness;
vec3 albedo;
vec3 viewDir;

Vertex RandomLightVertex() {
    float selectedArea = rand() * totalLightArea;

    // a is lower bound, b is upper bound
    int a = 0, b = textureSize(lightTex) - 1;
    vec2 data;
    while(b > a) {
        int m = (a + b) / 2;
        data = texelFetch(lightTex, m).xy; // Reading the who thing instead of just .x is not more expensive because of how GPUs work
        if(data.x > selectedArea)
            b = m; // We only know that m is *greater* than our target, so we cannot dismiss it via m - 1
        else
            a = m + 1; // We certainly know m cannot be it, so we set the bound to m + 1
    }

    CompactTriangle triangle = ReadCompactTriangle(fbs(data.y));

    vec2 r = rand2();

    // https://pharr.org/matt/blog/2019/02/27/triangle-sampling-1
    float sr = sqrt(r.x);
    float u = 1 - sr;
    float v = r.y * sr;
    float t = 1.0f - u - v;

    Vertex lightVertex;

    lightVertex.Position = triangle.position0 * u + triangle.position1 * v + triangle.position2 * t;
    lightVertex.TextureCoordinate = triangle.texcoord0 * u + triangle.texcoord1 * v + triangle.texcoord2 * t;
    lightVertex.Normal = triangle.normal;
    lightVertex.MatID = triangle.material;

    return lightVertex;
}

mat3 ConstructTBN(in vec3 normal) {
    vec3 normcrs = (abs(normal.y) > 0.99 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));
    vec3 tangent = normalize(cross(normcrs, normal));
    vec3 bitangent = cross(tangent, normal); 
    return mat3(tangent, bitangent, normal);
}

// I make the assumption that the sun is a disk with its center just 1 unit away from the vertex
// We can calculate our sampled point via c + tbn * (random 2d point within a unit circle * radius, 0.0f)
// Where c is the center of our disk, tbn is its coordinate system, and radius is the radius of the disk, which can easily be obtained from the tanget of a angular radius parameter
// But this is a very hacky and bad solution, ideally you want to solid angle sample a cone
// For more details, see "Monte Carlo Techniques for Direct Lighting Calculations" by Shirley et al.
uniform vec3 sunDir;// = normalize(vec3(2.0f, 9.0f, 12.0f));
uniform float sunRadius;// = 0.05f;
uniform float sunMaxDot;
float sunArea = M_PI * sunRadius * sunRadius;
Vertex RandomSunVertex(in Vertex vertex) {
    mat3 sunTBN = ConstructTBN(-sunDir);

    vec2 r = rand2();

    float radius = sunRadius * sqrt(r.x);
    float phi = 2 * M_PI * r.y;

    vec3 diskPosition = vec3(radius * vec2(cos(phi), sin(phi)), 0.0f);

    Vertex sunVertex;

    sunVertex.Position = vertex.Position + sunDir + sunTBN * diskPosition; 
    sunVertex.Normal = -sunDir;
    sunVertex.MatID = 0;

    return sunVertex;
}

Ray GenerateLightSample(in Vertex vertex, out HitInfo lightHit, out float lightPdf, in vec3 throughput, out vec3 lightThroughput, out uint lightMatID) { 
    float lightPick = rand();
    Vertex lightVertex;

    if(lightPick > 0.5f) {
        lightVertex = RandomLightVertex();
        lightPdf = 0.5f / totalLightArea;
        lightHit.di.x = distance(lightVertex.Position, vertex.Position) - 0.005f;
    } else {
        lightVertex = RandomSunVertex(vertex);
        lightPdf = 0.5f / sunArea;
        lightHit.di.x = 1e20f;//radius - 0.005f;
    }

    Ray lightRay;

    float radius = distance(lightVertex.Position, vertex.Position); 
    vec3 lightDir = normalize(lightVertex.Position - vertex.Position); 
    float bouncePdf = 0.5f * (GGX_PDF(vertex.Normal, viewDir, lightDir, roughness) + SamplePdfCosine(vertex.Normal, lightDir)) * nndot(lightVertex.Normal, -lightDir) / (radius * radius); // Seach veach 1995, eq 9
    lightThroughput = BRDF(albedo, metalness, roughness, vertex.Normal, viewDir, lightDir) * throughput * nndot(vertex.Normal, lightDir) * nndot(lightVertex.Normal, -lightDir) * MISWeight(lightPdf, bouncePdf) / (lightPdf * radius * radius);
             
    lightRay.origin = vertex.Position + 0.001f * lightDir;
    lightRay.direction = lightDir;

    lightMatID = lightVertex.MatID;

    return lightRay;
}

const float kRoughness = 1e-5f;

void main() {
	// Begin by getting to know which pixel we are in	
	ivec2 PixelCoordinates = ivec2(gl_GlobalInvocationID.xy);
    initRNG(PixelCoordinates.y * width + PixelCoordinates.x);

	// Generate our ray
	Ray ray;

    vec2 interpolation = (PixelCoordinates + rand2()) / vec2(width, height);

    vec2 r = rand2();
    float phi = 2 * M_PI * r.y; 
    float radius = sqrt(r.x);
    vec2 rd = lens_radius * r * vec2(cos(phi), sin(phi));
    vec3 offset = u * rd.x + v * rd.y;

    ray.origin    = position + offset;
    ray.direction = normalize(lower_left + interpolation.s * horizontal + interpolation.t * vertical - offset);

    vec3 throughput = vec3(1.0);
    vec3 contribution = vec3(0.0);

    Vertex vertex;
    float bxdfPdf = 1.0;
    float neePdf = 0.5f / totalLightArea;

    // TODO: clean up variable names
    viewDir = -ray.direction;
    vec3 lastPosition = ray.origin;

    // Set max bounce length to an inordinately high number so we (basically) get unbiased results while terminating the few odd rays that run for a lot of bounces without end
    const int kMaxBounces = 1024;
    for(int i = 0; i < kMaxBounces; i++) {
        // Intersect the scene
        HitInfo hit;
        hit.di.x = 1e20f;
        bool miss = !ClosestHit(ray, hit);
        vertex = GetInterpolatedVertex(ray, hit);
        if(miss) {
            vertex.MatID = 0;
        }

        // Account for L_e
        if(fbs(materialInstance[vertex.MatID + 1].w) == 1) {
            vec3 emission;
            if(vertex.MatID == 0) {
                // TODO: figure out how to factor in sunlight here
                // I think that we would have to weight the skybox and sunlight differently
                // At least energy loss is minimal atm and I can wait until I do away with area sampling and get into solid angle sampling stuff
                emission = texture(samplerCube(fbu(materialInstance[0].xy)), ray.direction).xyz;
            } else {
                emission = materialInstance[vertex.MatID + 1].xyz;
                if(i != 0) {
                    float dist = distance(lastPosition, vertex.Position);
                    bxdfPdf *= nndot(vertex.Normal, viewDir) / (dist * dist);
                    throughput *= MISWeight(bxdfPdf, neePdf);
                }
            }
            contribution += throughput * emission;
            break; // No indirect lighting except for zeroth bounce
        }
        if(dot(vertex.Normal, viewDir) < 0.0f){
            break;
        }

        // Sample the texture
        vec4 color = texture(sampler2D(fbu(materialInstance[vertex.MatID].xy)), vertex.TextureCoordinate);
        //#define TRANSPARENCY
        if(color.a != 1.0f) {
        #ifdef TRANSPARENCY
            i--;
            continue;
        #else
            break;
        #endif
        }

        albedo = color.xyz;
        vec4 materialInfo = texture(sampler2D(fbu(materialInstance[vertex.MatID].zw)), vertex.TextureCoordinate).xyzw;

        roughness = materialInfo.g * materialInfo.g;
        metalness = materialInfo.b;
        
        HitInfo lightHit;
        vec3 lightThroughput;
        uint lightMatID;
        float lightPdf;

        Ray lightRay = GenerateLightSample(vertex, lightHit, lightPdf, throughput, lightThroughput, lightMatID);                     
        if(!AnyHit(lightRay, lightHit)) {
            contribution += lightThroughput * materialInstance[lightMatID + 1].xyz;
        }

        // Construct a new ray
        float otherPdf;
        if(rand() > 0.5f) {
            vec3 h = ConstructTBN(vertex.Normal) * GGX_ImportanceSample(roughness);
            ray.direction = reflect(-viewDir, h);
            bxdfPdf = GGX_PDFH(vertex.Normal, viewDir, h, roughness); 
            otherPdf = SamplePdfCosine(vertex.Normal, ray.direction);
        } else {
            ray.direction = ConstructTBN(vertex.Normal) * ImportanceSampleCosine(bxdfPdf);
            otherPdf = GGX_PDF(vertex.Normal, viewDir, ray.direction, roughness);
        }

        // Russian roulette
        throughput *= BRDF(albedo, metalness, roughness, vertex.Normal, viewDir, ray.direction) * nndot(vertex.Normal, ray.direction) * MISWeight(bxdfPdf, otherPdf) / (0.5f * bxdfPdf); // We multiply the PDF by 0.5 since we had a 50/50 percent chance of choosing it
        float continuation = min(max(throughput.x, max(throughput.y, throughput.z)), 1.0f);
        if(rand() > continuation) {
            break;
        }
        throughput /= continuation;

        viewDir = -ray.direction;
        lastPosition = vertex.Position;
        ray.origin = vertex.Position + 0.001 * ray.direction;
    }

    vec3 accumContribution = imageLoad(accum, PixelCoordinates).xyz + contribution;
    imageStore(accum, PixelCoordinates,vec4(accumContribution, 1.0));

    freeRNG();
}

/*
    vec3 testDir = normalize(vec3(1.0, 1.0, 0.0));
    
    vec2 polarCoords = interpolation * vec2(2 * M_PI, M_PI / 2);

    float yaw = polarCoords.x;
    float pitch = polarCoords.y;

    vec3 direction;
    direction.x = cos(pitch) *  sin(yaw);
	direction.y = sin(pitch);
	direction.z = cos(pitch) * -cos(yaw);

    contribution = SingleScatterCookTorrace(vec3(1.0), roughness, metallic, vec3(0.0, 1.0, 0.0), direction, testDir);
*/

/*
 // Intersect the scene
        HitInfo hit;
        hit.di.x = 1e20f;
        bool miss = !ClosestHit(ray, hit);
        vertex = GetInterpolatedVertex(ray, hit);
        if(miss) {
            vertex.MatID = 0;
        }

        // Account for L_e
        if(fbs(materialInstance[vertex.MatID + 1].w) == 1) {
            vec3 emission;
            if(miss) {
                emission = texture(samplerCube(floatBitsToUint(materialInstance[0].xy)), -viewDir).xyz;
            } else {
                emission = materialInstance[vertex.MatID + 1].xyz;
                float radius = distance(lastPosition, vertex.Position);
                float lightPdf = neePdf * radius * radius / max(dot(vertex.Normal, viewDir), 0.001f);
                throughput *= MISWeight(bxdfPdf, lightPdf);
            }
            contribution += throughput * emission;
            break; // Assume f_r for all surfaces where L_e != 0 is 0
        }


        // Sample the texture
        vec3 albedo = texture(sampler2D(floatBitsToUint(materialInstance[vertex.MatID].xy)), vertex.TextureCoordinate).xyz;

        vec3 lightPosition, lightNormal;
        RandomPointOnLight(lightPosition, lightNormal);
        float radius = distance(vertex.Position, lightPosition);
        vec3 lightDir = (lightPosition - vertex.Position) / radius;
        float lightPdf = neePdf * radius * radius / max(dot(lightNormal, -lightDir), 0.001f);
        vec3 lightThroughput = throughput * (albedo / M_PI) * max(dot(vertex.Normal, lightDir), 0.0f) * max(dot(lightNormal, -lightDir), 0.0f) * MISWeight(lightPdf, max(dot(vertex.Normal, lightDir) / M_PI, 0.0f)) / (lightPdf * radius * radius);
        float lightContinuation = min(max(lightThroughput.x, max(lightThroughput.y, lightThroughput.z)), 1.0f);
        if(rand() < lightContinuation) {
            lightThroughput /= lightContinuation;

            HitInfo lightHit;
            lightHit.di.x = 1e20f;
             
            Ray lightRay;
            lightRay.origin = vertex.Position + 0.001 * vertex.Normal;
            lightRay.direction = lightDir;
                               
            if(ClosestHit(lightRay, lightHit)) {
                Vertex lightVertex = GetInterpolatedVertex(lightRay, lightHit);
                if(distance(lightVertex.Position, lightPosition) < 0.1f) {
                    // We hit the light
                    contribution += lightThroughput * materialInstance[lightVertex.MatID + 1].xyz;

                }
            }
        }

        // Construct a new ray
        vec3 normcrs = (abs(vertex.Normal.y) > 0.99 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));
        vec3 tangent = normalize(cross(normcrs, vertex.Normal));
        vec3 bitangent = cross(tangent, vertex.Normal); 
        ray.origin = vertex.Position + 0.001 * vertex.Normal;
        ray.direction = mat3(tangent, bitangent, vertex.Normal) * ImportanceSampleCosine(bxdfPdf);

        // Russian roulette
        throughput *= albedo;// / M_PI *  max(dot(vertex.Normal, ray.direction), 0.0f) / bxdfPdf;
        float continuation = min(max(throughput.x, max(throughput.y, throughput.z)), 1.0f);
        if(rand() > continuation) {
            break;
        }
        throughput /= continuation;

        viewDir = -ray.direction;
        lastPosition = vertex.Position;
*/