#version 430

#extension GL_ARB_bindless_texture : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "common/Geometry.glsl"
#include "common/BVH.glsl"
#include "common/Random.glsl"
#include "common/Constants.glsl"
#include "common/Util.glsl"

uniform vec3 lower_left, horizontal, vertical, position, u, v;
uniform int width, height;
uniform float lens_radius;

uniform layout(rgba32f) image2D accum;

layout(std430) readonly buffer samplers {
    vec4 materialInstance[];
};

vec3 CosineWeightedDirection() {
    float r0 = rand(), r1 = rand();
    float r = sqrt(r0); 
    float phi = 2 * M_PI * r1;
    return vec3(r * vec2(sin(phi), cos(phi)), sqrt(1.0 - r0));
}

void main() {
	// Begin by getting to know which pixel we are in	
	ivec2 PixelCoordinates = ivec2(gl_GlobalInvocationID.xy);
    initRNG(PixelCoordinates.y * width + PixelCoordinates.x);

	// Generate our ray
	Ray ray;

    vec2 interpolation = vec2(PixelCoordinates + vec2(rand(), rand())) / (vec2(width, height));
    float phi = 2 * M_PI * rand(); 
    float r = sqrt(rand());

    vec2 rd = lens_radius * r * vec2(cos(phi), sin(phi));
    vec3 offset = u * rd.x + v * rd.y;

    ray.origin    = position + offset;
    ray.direction = lower_left + interpolation.s * horizontal + interpolation.t * vertical - offset;

    vec3 throughput = vec3(1.0);
    vec3 contribution = vec3(0.0);

    Vertex vertex;

    // Set max bounce length to an inordinately high number so we (basically) get unbiased results while terminating the few odd rays that run for a lot of bounces without end
    const int kMaxBounces = 1024;
    for(int i = 0; i < kMaxBounces; i++) {
        // Intersect the scene
        HitInfo hit;
        hit.di.x = 1e20f;
        if(!TraverseBVH(ray, hit)) {
            break;
        }
        vertex = GetInterpolatedVertex(ray, hit);

        // Account for L_e
        if(fbs(materialInstance[vertex.MatID + 1].w) == 1) {
            contribution += throughput * materialInstance[vertex.MatID + 1].xyz;
            break;
        }

        // Sample the texture
        vec3 brdf = texture(sampler2D(floatBitsToUint(materialInstance[vertex.MatID].xy)), vertex.TextureCoordinate).xyz / M_PI;

        // Construct a new ray
        vec3 normcrs = (abs(vertex.Normal.y) > 0.99 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));
        vec3 tangent = normalize(cross(normcrs, vertex.Normal));
        vec3 bitangent = cross(tangent, vertex.Normal);
        ray.origin = vertex.Position + 0.001 * vertex.Normal;
        ray.direction = mat3(tangent, bitangent, vertex.Normal) * CosineWeightedDirection();

        // Russian roulette
        throughput *= brdf;
        float continuation = max(throughput.x, max(throughput.y, throughput.z));
        if(rand() > continuation) {
            break;
        }
        throughput /= continuation;
    }

    vec3 accumContribution = imageLoad(accum, PixelCoordinates).xyz + contribution;
    imageStore(accum, PixelCoordinates,vec4(accumContribution, 1.0));

    freeRNG();
}