#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "common/Geometry.glsl"
#include "common/Random.glsl"
#include "common/Constants.glsl"
#include "common/Util.glsl"

layout(binding = 0, offset = 0) uniform atomic_uint rayCounter;

layout(std430) writeonly buffer rayBufferW {
    vec4 raysW[];
};


uniform vec3 lower_left, horizontal, vertical, position, u, v;
uniform int width, height;
uniform float lens_radius;

void main() {
	uvec2 PixelCoordinates = gl_GlobalInvocationID.xy;
    initRNG(PixelCoordinates.y * width + PixelCoordinates.x);

    Ray ray;

    vec2 interpolation = vec2(PixelCoordinates + vec2(rand(), rand())) / (vec2(width, height));

    float phi = 2 * M_PI * rand(); 
    float r = sqrt(rand());

    vec2 rd = lens_radius * r * vec2(cos(phi), sin(phi));
    vec3 offset = u * rd.x + v * rd.y;

    ray.origin    = position + offset;
    ray.direction = lower_left + interpolation.s * horizontal + interpolation.t * vertical - offset;

    uint idx = atomicCounterIncrement(rayCounter) * 5;

    //rays[idx].origin = ray.Origin; 
    //rays[idx].direction = ray.Direction;
    //rays[idx].pixel = PixelCoordinates;

    const vec3 initThroughPut = vec3(1.0);
    const vec3 initAccumulated = vec3(0.0);
    
    raysW[idx  ].xy  = uintBitsToFloat(PixelCoordinates.xy);
    raysW[idx+1].xyz = initThroughPut;
    raysW[idx+1].w   = intBitsToFloat(0);
    raysW[idx+2].xyz = ray.origin;
    raysW[idx+3].xyz = ray.direction;
    
    freeRNG();
}