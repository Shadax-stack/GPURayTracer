#version 430

#extension GL_ARB_bindless_texture : enable

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#include "common/BVH.glsl"

layout(std430) buffer rayBufferW {
    vec4 raysW[];
};

layout(std430) buffer rayBufferR {
    vec4 raysR[];
};

layout(std430) readonly buffer samplers {
    vec4 materialInstance[];
};

layout(binding = 0, offset = 0) uniform atomic_uint raysWritten;
layout(binding = 0, offset = 8) uniform atomic_uint rayReadCounter;
layout(binding = 0, offset = 12) uniform atomic_uint rayWriteCounter;

void main(){
    uint idxR = atomicCounterIncrement(rayReadCounter);
    if(idxR >= atomicCounter(raysWritten)) return;
    idxR *= 5;

    ivec2 PixelCoordinates;
    Ray ray;
    vec3 throughPut, accum;

    PixelCoordinates.xy = floatBitsToInt( raysR[idxR].xy);
    throughPut.xy      = raysR[idxR  ].zw;
    throughPut.z       = raysR[idxR+1].x;
    accum              = raysR[idxR+1].yzw;
    ray.Origin    = raysR[idxR+2].xyz;
    ray.Direction = raysR[idxR+3].xyz;

    HitInfo IntersectionInfo;
    IntersectionInfo.Depth = 1e20;

    if(TraverseBVH(ray, IntersectionInfo)) {
        Vertex currVertex = GetInterpolatedVertex(IntersectionInfo);
        int matIdx = currVertex.MatID * 2;
        uint idxW = atomicCounterIncrement(rayWriteCounter) * 5;
        // overwrite our ray with our vertex
        raysW[idxW].xy    = intBitsToFloat(PixelCoordinates.xy);
        raysW[idxW  ].zw  = throughPut.xy;
        raysW[idxW+1].x   = throughPut.z;
        raysW[idxW+1].yzw = accum;
        raysW[idxW+2].xyz = currVertex.Position;
        raysW[idxW+2].w = currVertex.Normal.x;
        raysW[idxW+3].xy = currVertex.Normal.yz;
        raysW[idxW+3].zw = currVertex.TextureCoordinate;
        raysW[idxW+4].x = intBitsToFloat(currVertex.MatID * 2);
        
    }
    
            //imageStore(ColorOutput, ivec2(PixelCoordinates), vec4(ray.Origin , 1.0));
        //imageStore(ColorOutput, ivec2(PixelCoordinates), vec4(vec3(0.5), 1.0));

}