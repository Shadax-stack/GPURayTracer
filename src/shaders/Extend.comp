#version 430

#extension GL_ARB_bindless_texture : enable

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#include "common/BVH.glsl"

layout(std430) buffer rayBufferW {
    vec4 raysW[];
};

layout(std430) buffer rayBufferR {
    vec4 raysR[];
};

layout(binding = 0, offset = 0) uniform atomic_uint raysWritten;
layout(binding = 0, offset = 8) uniform atomic_uint rayReadCounter;
layout(binding = 0, offset = 12) uniform atomic_uint rayWriteCounter;

void main(){
    uint idxR = atomicCounterIncrement(rayReadCounter);
    if(idxR >= atomicCounter(raysWritten)) return;
    idxR *= 5;

    ivec2 PixelCoordinates;
    Ray ray;
    vec3 throughPut;
    int sampleType;

    PixelCoordinates.xy = floatBitsToInt( raysR[idxR].xy);
    throughPut         = raysR[idxR+1].xyz;
    sampleType         = fbs(raysR[idxR+1].w);
    ray.Origin    = raysR[idxR+2].xyz;
    ray.Direction = raysR[idxR+3].xyz;

    HitInfo IntersectionInfo;
    IntersectionInfo.di.x = 1e20;

    uint idxW = atomicCounterIncrement(rayWriteCounter) * 5;
    raysW[idxW].xy    = intBitsToFloat(PixelCoordinates.xy);
    raysW[idxW+1].xyz = throughPut;
    raysW[idxW+1].w   = intBitsToFloat(sampleType);
    if(TraverseBVH(ray, IntersectionInfo)) {
        Vertex currVertex = GetInterpolatedVertex(ray, IntersectionInfo);
        int matIdx = currVertex.MatID * 2; 
        // overwrite our ray with our vertex
        raysW[idxW+2].xyz = currVertex.Position;
        raysW[idxW+2].w = currVertex.Normal.x;
        raysW[idxW+3].xy = currVertex.Normal.yz;
        raysW[idxW+3].zw = currVertex.TextureCoordinate;
        raysW[idxW+4].x = intBitsToFloat(currVertex.MatID * 2);
    } else {
        raysW[idxW+4].x = intBitsToFloat(0);
    }

    raysW[idxW+4].yzw = ray.Direction;
            //imageStore(ColorOutput, ivec2(PixelCoordinates), vec4(ray.Origin , 1.0));

}