#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uniform layout(rgba16f) writeonly image2D ColorOutput;

void swap(inout float Arg0, inout float Arg1){
    float Temp = Arg0;
    Arg0 = Arg1;
    Arg1 = Temp;
    return;
}

// https://www.scratchapixel.com/code.php?id=52&origin=/lessons/procedural-generation-virtual-worlds/simulating-sky
bool SolveQuadratic(float a, float b, float c, out float x1, out float x2) 
{ 
    if (b == 0) { 
        // Handle special case where the the two vector ray.dir and V are perpendicular
        // with V = ray.orig - sphere.centre
        if (a == 0) return false; 
        x1 = 0; x2 = sqrt(-c / a); 
        return true; 
    } 
    float discr = b * b - 4 * a * c; 
 
    if (discr < 0) return false; 
 
    float q = (b < 0.f) ? -0.5f * (b - sqrt(discr)) : -0.5f * (b + sqrt(discr)); 
    x1 = q / a; 
    x2 = c / q; 
 
    return true; 
} 

// https://www.scratchapixel.com/code.php?id=52&origin=/lessons/procedural-generation-virtual-worlds/simulating-sky
bool RaySphereIntersect(vec3 orig, vec3 dir, float radius, out float t0, out float t1) 
{ 
    // They ray dir is normalized so A = 1 
    float A = dir.x * dir.x + dir.y * dir.y + dir.z * dir.z; 
    float B = 2 * (dir.x * orig.x + dir.y * orig.y + dir.z * orig.z); 
    float C = orig.x * orig.x + orig.y * orig.y + orig.z * orig.z - radius * radius; 
 
    if (!SolveQuadratic(A, B, C, t0, t1)) return false; 
 
    if (t0 > t1) swap(t0, t1); 
 
    return true; 
} 


vec3 ComputeColor(in vec2 PixelCoordinates){
	vec3 Color = vec3(0.0f);

	vec2 CameraExtent = vec2(16.0f, 9.0f) / 30.0f;
	vec3 RayDirection = normalize(vec3(mix(CameraExtent, -CameraExtent, vec2(gl_GlobalInvocationID.xy) / vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy)), -1.0f));

	Color = RayDirection;

    float temp[2];

    if(RaySphereIntersect(vec3(0.0f, 0.0f, -10.0f), RayDirection, 2.0f, temp[0], temp[1])) {
        Color = vec3(1.0f);
    }

	return Color;
}

void main(){
	uvec2 PixelCoordinates = gl_GlobalInvocationID.xy;

	imageStore(ColorOutput, ivec2(PixelCoordinates), vec4(ComputeColor(PixelCoordinates), 0.0f));
}