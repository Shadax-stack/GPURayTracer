#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uniform layout(rgba16f) writeonly image2D ColorOutput;

struct CameraParameters {
    vec3 Corner[2][2];

    vec3 Position;
};

uniform CameraParameters Camera;

vec3 ComputeRayDirection(in vec2 UV){

    vec3 Direction;

    vec3 Y[2];

    Y[0] = mix(Camera.Corner[0][0], Camera.Corner[0][1], UV.x);
    Y[1] = mix(Camera.Corner[1][0], Camera.Corner[1][1], UV.x);

    Direction = mix(Y[0], Y[1], UV.y);

    Direction = normalize(Direction);

    return Direction;
}

// Sky by builderboy
vec3 ComputeIncomingRadiance(in vec3 Direction) {
	float UpDot = Direction.y;
	const vec3 Coefficients = vec3(0.0625, 0.125, 0.25);
	vec3 Color = Coefficients / (UpDot * UpDot + Coefficients);
	return Color;
}

struct Vertex {
    vec3 Position;
    vec3 Normal;
    vec2 TextureCoordinate;
};

// Workaround for vec4 alignment
struct PackedVertex {
    // Position xyz, normal x
    vec4 PN;
    // Normal yz, tex coord xy
    vec4 NT;
};

Vertex UnpackVertex(in PackedVertex PV) {
    Vertex UnpackedVertex;

    UnpackedVertex.Position = PV.PN.xyz;

    UnpackedVertex.Normal.x  = PV.PN.w;
    UnpackedVertex.Normal.yz = PV.NT.xy;

    UnpackedVertex.TextureCoordinate = PV.NT.zw;

    return UnpackedVertex;
}

struct Triangle {
    Vertex[3] Vertices;
};

struct Ray {
    vec3 Origin;
    vec3 Direction;
};

struct VertexInterpolationInfo {
    float U, V;
};

struct TriangleHitInfo {
    Triangle IntersectedTriangle;
    VertexInterpolationInfo InterpolationInfo;
};

struct HitInfo {
    float Depth;
    TriangleHitInfo TriangleHitInfo;
};

struct TriangleIndexData {
    uint Indices[3];
};

layout(std430) readonly buffer VertexBuffer {
    PackedVertex BufferVertices[];
};

layout(std430) readonly buffer IndexBuffer {
    TriangleIndexData BufferElements[];
};

struct AABB {
    vec3 Position;
    vec3 Min;
    vec3 Max;
};

uniform AABB BoundingBox;

float IntersectPlane(in vec3 Origin, in vec3 Normal, in Ray Ray) {
    float DdotN = dot(Ray.Direction, Normal);
    vec3 TransformedOrigin = Origin - Ray.Origin;
    float TdotN = dot(TransformedOrigin, Normal);
    return TdotN / DdotN;
}

vec2 IntersectionAABBDistance(in AABB Box, in Ray Ray, uint Index) {
    vec2 Positions = vec2(Box.Min[Index], Box.Max[Index]);
    vec2 Distances = Positions / Ray.Direction[Index];
    if(Distances.x > Distances.y) {
        float Temp = Distances.x;
        Distances.x = Distances.y;
        Distances.y = Temp;
    }
    return Distances;
}

bool IntersectAABB(in AABB Box, in Ray Ray) {
    Box.Max += Box.Position;
    Box.Min += Box.Position;

    Box.Max -= Ray.Origin;
    Box.Min -= Ray.Origin;

    bool Result = false;

    vec2 T[3];

    T[0] = IntersectionAABBDistance(Box, Ray, 0);
    T[1] = IntersectionAABBDistance(Box, Ray, 1);
    T[2] = IntersectionAABBDistance(Box, Ray, 2);

    float tmin = T[0].x, tmax = T[0].y;
    float tymin = T[1].x, tymax = T[1].y;
    float tzmin = T[2].x, tzmax = T[2].y;

    if ((tmin > tymax) || (tymin > tmax)) 
        return false; 
 
    if (tymin > tmin) 
        tmin = tymin; 
 
    if (tymax < tmax) 
        tmax = tymax; 

    if ((tmin > tzmax) || (tzmin > tmax)) 
        return false; 
 
    if (tzmin > tmin) 
        tmin = tzmin; 
 
    if (tzmax < tmax) 
        tmax = tzmax; 

    return Result;
}

bool IntersectAABB2(in AABB Box, in Ray Ray) {
    Box.Max += Box.Position;
    Box.Min += Box.Position;

    vec3 InverseDirection = 1.0f / Ray.Direction;

    vec3 tbot = InverseDirection * (Box.Min - Ray.Origin);
    vec3 ttop = InverseDirection * (Box.Max - Ray.Origin);

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    vec2 t = max(tmin.xx, tmin.yz);
    float t0 = max(t.x, t.y);

    t = min(tmax.xx, tmax.yz);
    float t1 = min(t.x, t.y);

    return t1 > max(t0, 0.0);
}

bool IntersectTriangle(in Triangle Triangle, in Ray Ray, inout HitInfo Hit) {
    // this is mostly a copy paste from scratchapixel's code that has been refitted to work with GLSL

    TriangleHitInfo TentativeTriangleHitInfo;
    TentativeTriangleHitInfo.IntersectedTriangle = Triangle;

    vec3 V01 = Triangle.Vertices[1].Position.xyz - Triangle.Vertices[0].Position.xyz;
    vec3 V02 = Triangle.Vertices[2].Position.xyz - Triangle.Vertices[0].Position.xyz;

    vec3 Pvec = cross(Ray.Direction, V02);

    float det = dot(V01, Pvec);

    const float Epsilon = 1e-6f;
    if (abs(det) < Epsilon) {
        return false;
    }

    float invDet = 1.0f / det;

    vec3 Tvec = Ray.Origin - Triangle.Vertices[0].Position;
    TentativeTriangleHitInfo.InterpolationInfo.U = dot(Tvec, Pvec) * invDet;
    if (TentativeTriangleHitInfo.InterpolationInfo.U < 0 || TentativeTriangleHitInfo.InterpolationInfo.U > 1) return false;

    vec3 Qvec = cross(Tvec, V01);
    TentativeTriangleHitInfo.InterpolationInfo.V = dot(Ray.Direction, Qvec) * invDet;
    if (TentativeTriangleHitInfo.InterpolationInfo.V < 0 || TentativeTriangleHitInfo.InterpolationInfo.U + TentativeTriangleHitInfo.InterpolationInfo.V  > 1) return false;

    float t = dot(V02, Qvec) * invDet;

    if (t < Hit.Depth && t > 0.0f) {
        Hit.Depth = t;
        Hit.TriangleHitInfo = TentativeTriangleHitInfo;
        return true;
    } else {
        return false;
    }
}

Vertex GetInterpolatedVertex(in HitInfo Intersection) {
    Vertex InterpolatedVertex;

    // I should probably precompute 1 - U - V

    InterpolatedVertex.Position =

    	Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[1].Position  * Intersection.TriangleHitInfo.InterpolationInfo.U +
		Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[2].Position  * Intersection.TriangleHitInfo.InterpolationInfo.V +
		Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[0].Position  * (1.0f - Intersection.TriangleHitInfo.InterpolationInfo.U - Intersection.TriangleHitInfo.InterpolationInfo.V)

	;

    InterpolatedVertex.Normal =

    	Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[1].Normal  * Intersection.TriangleHitInfo.InterpolationInfo.U +
		Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[2].Normal  * Intersection.TriangleHitInfo.InterpolationInfo.V +
		Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[0].Normal  * (1.0f - Intersection.TriangleHitInfo.InterpolationInfo.U - Intersection.TriangleHitInfo.InterpolationInfo.V)

	;

    InterpolatedVertex.TextureCoordinate =

    	Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[1].TextureCoordinate  * Intersection.TriangleHitInfo.InterpolationInfo.U +
		Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[2].TextureCoordinate  * Intersection.TriangleHitInfo.InterpolationInfo.V +
		Intersection.TriangleHitInfo.IntersectedTriangle.Vertices[0].TextureCoordinate  * (1.0f - Intersection.TriangleHitInfo.InterpolationInfo.U - Intersection.TriangleHitInfo.InterpolationInfo.V)

	;

    InterpolatedVertex.Normal = normalize(InterpolatedVertex.Normal);

    return InterpolatedVertex;
}


struct MaterialSamplers {
    sampler2D Albedo;
};

uniform MaterialSamplers Material;


vec3 ComputeColor(in vec2 PixelCoordinates){
    vec2 ScreenCoordinates = PixelCoordinates / vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    vec3 Color = vec3(0.0f);

    Ray PrimaryRay;

    PrimaryRay.Origin    = Camera.Position;
    PrimaryRay.Direction = ComputeRayDirection(ScreenCoordinates);

    HitInfo IntersectionInfo;

    IntersectionInfo.Depth = 1.0e20f;

    bool HitResult = false;

    if(IntersectAABB2(BoundingBox, PrimaryRay)) {
        for(uint TriangleIndex = 0; TriangleIndex < BufferElements.length(); TriangleIndex++) {
            // Assemble the triangle

            TriangleIndexData CurrentIndexData = BufferElements[TriangleIndex];

            Triangle CurrentTriangle;

            CurrentTriangle.Vertices[0] = UnpackVertex(BufferVertices[CurrentIndexData.Indices[0]]);
            CurrentTriangle.Vertices[1] = UnpackVertex(BufferVertices[CurrentIndexData.Indices[1]]);
            CurrentTriangle.Vertices[2] = UnpackVertex(BufferVertices[CurrentIndexData.Indices[2]]);

            bool TriangleHit = IntersectTriangle(CurrentTriangle, PrimaryRay, IntersectionInfo);

            HitResult = HitResult || TriangleHit;
        }
    }

    if(HitResult) {
        Vertex InterpolatedVertex = GetInterpolatedVertex(IntersectionInfo);

        Color = texture(Material.Albedo, InterpolatedVertex.TextureCoordinate).rgb;
    } else {
        Color = ComputeIncomingRadiance(PrimaryRay.Direction);
    }

    // TODO: More accurate sRGB conversion
    Color = pow(Color, vec3(1.0f / 2.2f));

	return Color;
}

void main(){
	uvec2 PixelCoordinates = gl_GlobalInvocationID.xy;
    ivec2 StoreLocation = ivec2(PixelCoordinates);

    vec3 Color = ComputeColor(PixelCoordinates);

	imageStore(ColorOutput, StoreLocation, vec4(Color, 0.0f));
}