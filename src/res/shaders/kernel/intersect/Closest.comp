#version 430

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// RGB = color, A = depth
uniform layout(rgba16f) image2D ColorOutput;
uniform layout(rgba16f) image2D RayOrigin;
uniform layout(rgba16f) image2D RayDirection;
uniform layout(r32f)    image2D IntersectionDepth;

//uniform sampler2D RayOrigin;
//uniform sampler2D RayDirection;

#include "../../shading/BRDF.glsl"
#include "../../shading/Material.glsl"
#include "../../camera/Pinhole.glsl"
#include "../../geometry/Triangle.glsl"
#include "../../geometry/AABB.glsl"
#include "../../accelstruct/BVH/Traverse.glsl"

// Sky by builderboy
// Original coeffs: vec3(0.0625, 0.125, 0.25)
vec3 ComputeIncomingRadiance(in vec3 Direction) {
	float UpDot = Direction.y;
	const vec3 Coefficients =vec3(0.0625, 0.125, 0.25); //  0.1686, 0.4, 0.8667
	vec3 Color = Coefficients / (UpDot * UpDot + Coefficients);
	return Color;
}

uniform MeshSamplers Mesh;
uniform MaterialSamplers Material;
uniform BVHSamplers BVH;

vec3 ComputeColor(in ivec2 PixelCoordinates, inout float IntersectionDepthDistance, inout bool HitResult){
    vec3 Color = vec3(0.0f);

    Ray PrimaryRay;
    
    PrimaryRay.Origin    = imageLoad(RayOrigin   , PixelCoordinates).rgb;
    PrimaryRay.Direction = imageLoad(RayDirection, PixelCoordinates).rgb;

    // Initialize our intersection data based off the last intersection test with the previous mesh within our scene
    HitInfo IntersectionInfo;
    IntersectionInfo.Depth = IntersectionDepthDistance;

    if(HitResult = TraverseBVH(Mesh, BVH, PrimaryRay, IntersectionInfo)) {
        Vertex InterpolatedVertex = GetInterpolatedVertex(IntersectionInfo);

        Color = texture(Material.Diffuse, InterpolatedVertex.TextureCoordinate).rgb;
        // TODO: More accurate sRGB conversion
        Color = pow(Color, vec3(1.0f / 2.2f));
    } else {
        // Basically if the intersection depth is a specific very large number (ie nothing as been hit yet) we wipe the screen with the sky Color
        // Then the intersection depth is replaced with a slightly smaller but still large number that is not equal to the specific number in the first place
        if(IntersectionInfo.Depth == 1e20) {
            HitResult = true; 
            IntersectionInfo.Depth = 1e19;
        }
        Color = ComputeIncomingRadiance(PrimaryRay.Direction);
    }

    IntersectionDepthDistance = IntersectionInfo.Depth;

	return Color;
}

void main(){
	uvec2 PixelCoordinates = gl_GlobalInvocationID.xy;
    ivec2 StoreLocation = ivec2(PixelCoordinates);

    float IntersectionDistance = imageLoad(IntersectionDepth, StoreLocation).r;
    bool HitResult;

    vec3 Color = ComputeColor(StoreLocation, IntersectionDistance, HitResult);

    if(HitResult){
        imageStore(IntersectionDepth, StoreLocation, vec4(IntersectionDistance));
        
        imageStore(ColorOutput, StoreLocation, vec4(Color, 1.0f));
    }

}

/*
vec4 ComputeColor(in ivec2 PixelCoordinates){
    vec3 Color = vec3(0.0f);

    Ray PrimaryRay;
    // I could use texelFetch here but whatever
    PrimaryRay.Origin    = imageLoad(RayOrigin   , PixelCoordinates).rgb;
    PrimaryRay.Direction = imageLoad(RayDirection, PixelCoordinates).rgb;

    HitInfo IntersectionInfo;

    IntersectionInfo.Depth = imageLoad(IntersectionDepth, PixelCoordinates).r;

    bool HitResult = TraverseBVH(Mesh, BVH, PrimaryRay, IntersectionInfo);

    if(HitResult) {
        Vertex InterpolatedVertex = GetInterpolatedVertex(IntersectionInfo);

        Color = vec3(1.0f);//texture(Material.Diffuse, InterpolatedVertex.TextureCoordinate).rgb;

        // Reflection and refraction

        vec3 RefractedRay = refract(PrimaryRay.Direction, InterpolatedVertex.Normal, 1.0 / 1.333f);
        vec3 ReflectedRay = reflect(PrimaryRay.Direction, InterpolatedVertex.Normal);

        Color *= (ComputeIncomingRadiance(RefractedRay) + ComputeIncomingRadiance(ReflectedRay)) / 2.0f;
    } else {
        Color = ComputeIncomingRadiance(PrimaryRay.Direction);
    }

    // TODO: More accurate sRGB conversion
    Color = pow(Color, vec3(1.0f / 2.2f));

	return vec4(Color, IntersectionInfo.Depth);
}

void main(){
	uvec2 PixelCoordinates = gl_GlobalInvocationID.xy;
    ivec2 StoreLocation = ivec2(PixelCoordinates);

    vec4 Color = ComputeColor(StoreLocation);
    
    if(StoreLocation.x > 640)
    imageStore(ColorOutput, StoreLocation, vec4(Color.w / 500.0f));
    imageStore(IntersectionDepth, StoreLocation, vec4(Color.w));
}
*/